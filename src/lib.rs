//!Peripheral access API for SF32LB52X microcontrollers (generated using svd2rust v0.35.0 ( ))
//!
//!You can find an overview of the generated API [here].
//!
//!API features to be included in the [next]
//!svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.
//!
//![here]: https://docs.rs/svd2rust/0.35.0/svd2rust/#peripheral-api
//![next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased
//![repository]: https://github.com/rust-embedded/svd2rust
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
///Number available in the NVIC for configuring priority
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
///Common register and bit access and modify traits
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 0] = [];
///Enumeration of all the interrupts.
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Interrupt {}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        match self {}
    }
}
///HPSYS_RCC
pub struct HpsysRcc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HpsysRcc {}
impl HpsysRcc {
    ///Pointer to the register block
    pub const PTR: *const hpsys_rcc::RegisterBlock = 0x5000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const hpsys_rcc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HpsysRcc {
    type Target = hpsys_rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HpsysRcc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HpsysRcc").finish()
    }
}
///HPSYS_RCC
pub mod hpsys_rcc;
///EXTDMA
pub struct Extdma {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Extdma {}
impl Extdma {
    ///Pointer to the register block
    pub const PTR: *const extdma::RegisterBlock = 0x5000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const extdma::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Extdma {
    type Target = extdma::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Extdma {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Extdma").finish()
    }
}
///EXTDMA
pub mod extdma;
///HPSYS_PINMUX
pub struct HpsysPinmux {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HpsysPinmux {}
impl HpsysPinmux {
    ///Pointer to the register block
    pub const PTR: *const hpsys_pinmux::RegisterBlock = 0x5000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const hpsys_pinmux::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HpsysPinmux {
    type Target = hpsys_pinmux::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HpsysPinmux {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HpsysPinmux").finish()
    }
}
///HPSYS_PINMUX
pub mod hpsys_pinmux;
///ATIM1
pub struct Atim1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Atim1 {}
impl Atim1 {
    ///Pointer to the register block
    pub const PTR: *const atim1::RegisterBlock = 0x5000_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const atim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Atim1 {
    type Target = atim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Atim1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Atim1").finish()
    }
}
///ATIM1
pub mod atim1;
///AUDPRC
pub struct Audprc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Audprc {}
impl Audprc {
    ///Pointer to the register block
    pub const PTR: *const audprc::RegisterBlock = 0x5000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const audprc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Audprc {
    type Target = audprc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Audprc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Audprc").finish()
    }
}
///AUDPRC
pub mod audprc;
///EZIP1
pub struct Ezip1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ezip1 {}
impl Ezip1 {
    ///Pointer to the register block
    pub const PTR: *const ezip1::RegisterBlock = 0x5000_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const ezip1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ezip1 {
    type Target = ezip1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ezip1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ezip1").finish()
    }
}
///EZIP1
pub mod ezip1;
///EPIC
pub struct Epic {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Epic {}
impl Epic {
    ///Pointer to the register block
    pub const PTR: *const epic::RegisterBlock = 0x5000_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const epic::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Epic {
    type Target = epic::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Epic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Epic").finish()
    }
}
///EPIC
pub mod epic;
///LCDC1
pub struct Lcdc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lcdc1 {}
impl Lcdc1 {
    ///Pointer to the register block
    pub const PTR: *const lcdc1::RegisterBlock = 0x5000_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lcdc1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lcdc1 {
    type Target = lcdc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lcdc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lcdc1").finish()
    }
}
///LCDC1
pub mod lcdc1;
///I2S1
pub struct I2s1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s1 {}
impl I2s1 {
    ///Pointer to the register block
    pub const PTR: *const i2s1::RegisterBlock = 0x5000_9000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2s1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s1 {
    type Target = i2s1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s1").finish()
    }
}
///I2S1
pub mod i2s1;
///HPSYS_CFG
pub struct HpsysCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HpsysCfg {}
impl HpsysCfg {
    ///Pointer to the register block
    pub const PTR: *const hpsys_cfg::RegisterBlock = 0x5000_b000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const hpsys_cfg::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HpsysCfg {
    type Target = hpsys_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HpsysCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HpsysCfg").finish()
    }
}
///HPSYS_CFG
pub mod hpsys_cfg;
///EFUSEC
pub struct Efusec {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Efusec {}
impl Efusec {
    ///Pointer to the register block
    pub const PTR: *const efusec::RegisterBlock = 0x5000_c000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const efusec::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Efusec {
    type Target = efusec::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Efusec {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Efusec").finish()
    }
}
///EFUSEC
pub mod efusec;
///AES
pub struct Aes {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Aes {}
impl Aes {
    ///Pointer to the register block
    pub const PTR: *const aes::RegisterBlock = 0x5000_d000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const aes::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Aes {
    type Target = aes::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Aes {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Aes").finish()
    }
}
///AES
pub mod aes;
///TRNG
pub struct Trng {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Trng {}
impl Trng {
    ///Pointer to the register block
    pub const PTR: *const trng::RegisterBlock = 0x5000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const trng::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Trng {
    type Target = trng::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Trng {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Trng").finish()
    }
}
///TRNG
pub mod trng;
///MPI1
pub struct Mpi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mpi1 {}
impl Mpi1 {
    ///Pointer to the register block
    pub const PTR: *const mpi1::RegisterBlock = 0x5004_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const mpi1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mpi1 {
    type Target = mpi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mpi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mpi1").finish()
    }
}
///MPI1
pub mod mpi1;
///MPI2
pub struct Mpi2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mpi2 {}
impl Mpi2 {
    ///Pointer to the register block
    pub const PTR: *const mpi2::RegisterBlock = 0x5004_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const mpi2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mpi2 {
    type Target = mpi2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mpi2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mpi2").finish()
    }
}
///MPI2
pub mod mpi2;
///SDMMC1
pub struct Sdmmc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdmmc1 {}
impl Sdmmc1 {
    ///Pointer to the register block
    pub const PTR: *const sdmmc1::RegisterBlock = 0x5004_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const sdmmc1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sdmmc1 {
    type Target = sdmmc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdmmc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdmmc1").finish()
    }
}
///SDMMC1
pub mod sdmmc1;
///CRC1
pub struct Crc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crc1 {}
impl Crc1 {
    ///Pointer to the register block
    pub const PTR: *const crc1::RegisterBlock = 0x5004_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const crc1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crc1 {
    type Target = crc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crc1").finish()
    }
}
///CRC1
pub mod crc1;
///PTC1
pub struct Ptc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ptc1 {}
impl Ptc1 {
    ///Pointer to the register block
    pub const PTR: *const ptc1::RegisterBlock = 0x5008_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const ptc1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ptc1 {
    type Target = ptc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ptc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ptc1").finish()
    }
}
///PTC1
pub mod ptc1;
///DMAC1
pub struct Dmac1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmac1 {}
impl Dmac1 {
    ///Pointer to the register block
    pub const PTR: *const dmac1::RegisterBlock = 0x5008_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dmac1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmac1 {
    type Target = dmac1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmac1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac1").finish()
    }
}
///DMAC1
pub mod dmac1;
///USART1
pub struct Usart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart1 {}
impl Usart1 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x5008_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart1").finish()
    }
}
///USART1
pub mod usart1;
///USART2
pub struct Usart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart2 {}
impl Usart2 {
    ///Pointer to the register block
    pub const PTR: *const usart2::RegisterBlock = 0x5008_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart2 {
    type Target = usart2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart2").finish()
    }
}
///USART2
pub mod usart2;
///USART3
pub struct Usart3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart3 {}
impl Usart3 {
    ///Pointer to the register block
    pub const PTR: *const usart3::RegisterBlock = 0x5008_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart3::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart3 {
    type Target = usart3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart3").finish()
    }
}
///USART3
pub mod usart3;
///GPADC
pub struct Gpadc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpadc {}
impl Gpadc {
    ///Pointer to the register block
    pub const PTR: *const gpadc::RegisterBlock = 0x5008_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpadc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpadc {
    type Target = gpadc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpadc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpadc").finish()
    }
}
///GPADC
pub mod gpadc;
///AUDCODEC
pub struct Audcodec {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Audcodec {}
impl Audcodec {
    ///Pointer to the register block
    pub const PTR: *const audcodec::RegisterBlock = 0x5008_8000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const audcodec::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Audcodec {
    type Target = audcodec::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Audcodec {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Audcodec").finish()
    }
}
///AUDCODEC
pub mod audcodec;
///TSEN
pub struct Tsen {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tsen {}
impl Tsen {
    ///Pointer to the register block
    pub const PTR: *const tsen::RegisterBlock = 0x5008_9000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tsen::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tsen {
    type Target = tsen::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tsen {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tsen").finish()
    }
}
///TSEN
pub mod tsen;
///GPTIM1
pub struct Gptim1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gptim1 {}
impl Gptim1 {
    ///Pointer to the register block
    pub const PTR: *const gptim1::RegisterBlock = 0x5009_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gptim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gptim1 {
    type Target = gptim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gptim1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gptim1").finish()
    }
}
///GPTIM1
pub mod gptim1;
///BTIM1
pub struct Btim1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Btim1 {}
impl Btim1 {
    ///Pointer to the register block
    pub const PTR: *const btim1::RegisterBlock = 0x5009_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const btim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Btim1 {
    type Target = btim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Btim1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Btim1").finish()
    }
}
///BTIM1
pub mod btim1;
///WDT1
pub struct Wdt1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt1 {}
impl Wdt1 {
    ///Pointer to the register block
    pub const PTR: *const wdt1::RegisterBlock = 0x5009_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const wdt1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt1 {
    type Target = wdt1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt1").finish()
    }
}
///WDT1
pub mod wdt1;
///SPI1
pub struct Spi1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi1 {}
impl Spi1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x5009_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi1").finish()
    }
}
///SPI1
pub mod spi1;
///SPI2
pub struct Spi2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spi2 {}
impl Spi2 {
    ///Pointer to the register block
    pub const PTR: *const spi2::RegisterBlock = 0x5009_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spi2 {
    type Target = spi2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spi2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi2").finish()
    }
}
///SPI2
pub mod spi2;
///PDM1
pub struct Pdm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdm1 {}
impl Pdm1 {
    ///Pointer to the register block
    pub const PTR: *const pdm1::RegisterBlock = 0x5009_a000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pdm1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdm1 {
    type Target = pdm1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdm1").finish()
    }
}
///PDM1
pub mod pdm1;
///I2C1
pub struct I2c1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c1 {}
impl I2c1 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x5009_c000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c1").finish()
    }
}
///I2C1
pub mod i2c1;
///I2C2
pub struct I2c2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c2 {}
impl I2c2 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x5009_d000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c2 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c2").finish()
    }
}
///I2C2
pub use self::i2c1 as i2c2;
///I2C3
pub struct I2c3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c3 {}
impl I2c3 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x5009_e000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c3 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c3").finish()
    }
}
///I2C3
pub use self::i2c1 as i2c3;
///I2C4
pub struct I2c4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2c4 {}
impl I2c4 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x5009_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2c4 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2c4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c4").finish()
    }
}
///I2C4
pub use self::i2c1 as i2c4;
///HPSYS_GPIO
pub struct HpsysGpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HpsysGpio {}
impl HpsysGpio {
    ///Pointer to the register block
    pub const PTR: *const hpsys_gpio::RegisterBlock = 0x500a_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const hpsys_gpio::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HpsysGpio {
    type Target = hpsys_gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HpsysGpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HpsysGpio").finish()
    }
}
///HPSYS_GPIO
pub mod hpsys_gpio;
///GPTIM2
pub struct Gptim2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gptim2 {}
impl Gptim2 {
    ///Pointer to the register block
    pub const PTR: *const gptim1::RegisterBlock = 0x500b_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gptim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gptim2 {
    type Target = gptim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gptim2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gptim2").finish()
    }
}
///GPTIM2
pub use self::gptim1 as gptim2;
///BTIM2
pub struct Btim2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Btim2 {}
impl Btim2 {
    ///Pointer to the register block
    pub const PTR: *const btim1::RegisterBlock = 0x500b_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const btim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Btim2 {
    type Target = btim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Btim2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Btim2").finish()
    }
}
///BTIM2
pub use self::btim1 as btim2;
///HPSYS_AON
pub struct HpsysAon {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for HpsysAon {}
impl HpsysAon {
    ///Pointer to the register block
    pub const PTR: *const hpsys_aon::RegisterBlock = 0x500c_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const hpsys_aon::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for HpsysAon {
    type Target = hpsys_aon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for HpsysAon {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("HpsysAon").finish()
    }
}
///HPSYS_AON
pub mod hpsys_aon;
///LPTIM1
pub struct Lptim1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lptim1 {}
impl Lptim1 {
    ///Pointer to the register block
    pub const PTR: *const lptim1::RegisterBlock = 0x500c_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lptim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lptim1 {
    type Target = lptim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lptim1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lptim1").finish()
    }
}
///LPTIM1
pub mod lptim1;
///LPTIM2
pub struct Lptim2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lptim2 {}
impl Lptim2 {
    ///Pointer to the register block
    pub const PTR: *const lptim2::RegisterBlock = 0x500c_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lptim2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lptim2 {
    type Target = lptim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lptim2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lptim2").finish()
    }
}
///LPTIM2
pub mod lptim2;
///PMUC
pub struct Pmuc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmuc {}
impl Pmuc {
    ///Pointer to the register block
    pub const PTR: *const pmuc::RegisterBlock = 0x500c_a000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pmuc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmuc {
    type Target = pmuc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmuc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmuc").finish()
    }
}
///PMUC
pub mod pmuc;
///IWDT
pub struct Iwdt {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Iwdt {}
impl Iwdt {
    ///Pointer to the register block
    pub const PTR: *const iwdt::RegisterBlock = 0x500c_c000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const iwdt::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Iwdt {
    type Target = iwdt::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Iwdt {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Iwdt").finish()
    }
}
///IWDT
pub mod iwdt;
///LPSYS_RCC
pub struct LpsysRcc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LpsysRcc {}
impl LpsysRcc {
    ///Pointer to the register block
    pub const PTR: *const lpsys_rcc::RegisterBlock = 0x4000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lpsys_rcc::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LpsysRcc {
    type Target = lpsys_rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LpsysRcc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpsysRcc").finish()
    }
}
///LPSYS_RCC
pub mod lpsys_rcc;
///DMAC2
pub struct Dmac2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmac2 {}
impl Dmac2 {
    ///Pointer to the register block
    pub const PTR: *const dmac2::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dmac2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmac2 {
    type Target = dmac2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmac2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac2").finish()
    }
}
///DMAC2
pub mod dmac2;
///LPSYS_PINMUX
pub struct LpsysPinmux {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LpsysPinmux {}
impl LpsysPinmux {
    ///Pointer to the register block
    pub const PTR: *const lpsys_pinmux::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lpsys_pinmux::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LpsysPinmux {
    type Target = lpsys_pinmux::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LpsysPinmux {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpsysPinmux").finish()
    }
}
///LPSYS_PINMUX
pub mod lpsys_pinmux;
///USART4
pub struct Usart4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart4 {}
impl Usart4 {
    ///Pointer to the register block
    pub const PTR: *const usart4::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart4::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart4 {
    type Target = usart4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart4").finish()
    }
}
///USART4
pub mod usart4;
///USART5
pub struct Usart5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usart5 {}
impl Usart5 {
    ///Pointer to the register block
    pub const PTR: *const usart5::RegisterBlock = 0x4000_6000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart5::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usart5 {
    type Target = usart5::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usart5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usart5").finish()
    }
}
///USART5
pub mod usart5;
///BTIM3
pub struct Btim3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Btim3 {}
impl Btim3 {
    ///Pointer to the register block
    pub const PTR: *const btim1::RegisterBlock = 0x4000_9000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const btim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Btim3 {
    type Target = btim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Btim3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Btim3").finish()
    }
}
///BTIM3
pub use self::btim1 as btim3;
///BTIM4
pub struct Btim4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Btim4 {}
impl Btim4 {
    ///Pointer to the register block
    pub const PTR: *const btim1::RegisterBlock = 0x4000_a000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const btim1::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Btim4 {
    type Target = btim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Btim4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Btim4").finish()
    }
}
///BTIM4
pub use self::btim1 as btim4;
///WDT2
pub struct Wdt2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Wdt2 {}
impl Wdt2 {
    ///Pointer to the register block
    pub const PTR: *const wdt2::RegisterBlock = 0x4000_b000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const wdt2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Wdt2 {
    type Target = wdt2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Wdt2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Wdt2").finish()
    }
}
///WDT2
pub mod wdt2;
///PTC2
pub struct Ptc2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ptc2 {}
impl Ptc2 {
    ///Pointer to the register block
    pub const PTR: *const ptc2::RegisterBlock = 0x4000_c000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const ptc2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ptc2 {
    type Target = ptc2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ptc2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ptc2").finish()
    }
}
///PTC2
pub mod ptc2;
///LPSYS_CFG
pub struct LpsysCfg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LpsysCfg {}
impl LpsysCfg {
    ///Pointer to the register block
    pub const PTR: *const lpsys_cfg::RegisterBlock = 0x4000_f000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lpsys_cfg::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LpsysCfg {
    type Target = lpsys_cfg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LpsysCfg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpsysCfg").finish()
    }
}
///LPSYS_CFG
pub mod lpsys_cfg;
///LPSYS_AON
pub struct LpsysAon {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LpsysAon {}
impl LpsysAon {
    ///Pointer to the register block
    pub const PTR: *const lpsys_aon::RegisterBlock = 0x4004_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lpsys_aon::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for LpsysAon {
    type Target = lpsys_aon::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for LpsysAon {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("LpsysAon").finish()
    }
}
///LPSYS_AON
pub mod lpsys_aon;
///LPTIM3
pub struct Lptim3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lptim3 {}
impl Lptim3 {
    ///Pointer to the register block
    pub const PTR: *const lptim3::RegisterBlock = 0x4004_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const lptim3::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lptim3 {
    type Target = lptim3::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lptim3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lptim3").finish()
    }
}
///LPTIM3
pub mod lptim3;
///CRC2
pub struct Crc2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crc2 {}
impl Crc2 {
    ///Pointer to the register block
    pub const PTR: *const crc2::RegisterBlock = 0x4008_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const crc2::RegisterBlock {
        Self::PTR
    }
    /// Steal an instance of this peripheral
    ///
    /// # Safety
    ///
    /// Ensure that the new instance of the peripheral cannot be used in a way
    /// that may race with any existing instances, for example by only
    /// accessing read-only or write-only registers, or by consuming the
    /// original peripheral and using critical sections to coordinate
    /// access between multiple new instances.
    ///
    /// Additionally, other software such as HALs may rely on only one
    /// peripheral instance existing to ensure memory safety; ensure
    /// no stolen instances are passed to such software.
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crc2 {
    type Target = crc2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crc2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crc2").finish()
    }
}
///CRC2
pub mod crc2;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
/// All the peripherals.
#[allow(non_snake_case)]
pub struct Peripherals {
    ///HPSYS_RCC
    pub hpsys_rcc: HpsysRcc,
    ///EXTDMA
    pub extdma: Extdma,
    ///HPSYS_PINMUX
    pub hpsys_pinmux: HpsysPinmux,
    ///ATIM1
    pub atim1: Atim1,
    ///AUDPRC
    pub audprc: Audprc,
    ///EZIP1
    pub ezip1: Ezip1,
    ///EPIC
    pub epic: Epic,
    ///LCDC1
    pub lcdc1: Lcdc1,
    ///I2S1
    pub i2s1: I2s1,
    ///HPSYS_CFG
    pub hpsys_cfg: HpsysCfg,
    ///EFUSEC
    pub efusec: Efusec,
    ///AES
    pub aes: Aes,
    ///TRNG
    pub trng: Trng,
    ///MPI1
    pub mpi1: Mpi1,
    ///MPI2
    pub mpi2: Mpi2,
    ///SDMMC1
    pub sdmmc1: Sdmmc1,
    ///CRC1
    pub crc1: Crc1,
    ///PTC1
    pub ptc1: Ptc1,
    ///DMAC1
    pub dmac1: Dmac1,
    ///USART1
    pub usart1: Usart1,
    ///USART2
    pub usart2: Usart2,
    ///USART3
    pub usart3: Usart3,
    ///GPADC
    pub gpadc: Gpadc,
    ///AUDCODEC
    pub audcodec: Audcodec,
    ///TSEN
    pub tsen: Tsen,
    ///GPTIM1
    pub gptim1: Gptim1,
    ///BTIM1
    pub btim1: Btim1,
    ///WDT1
    pub wdt1: Wdt1,
    ///SPI1
    pub spi1: Spi1,
    ///SPI2
    pub spi2: Spi2,
    ///PDM1
    pub pdm1: Pdm1,
    ///I2C1
    pub i2c1: I2c1,
    ///I2C2
    pub i2c2: I2c2,
    ///I2C3
    pub i2c3: I2c3,
    ///I2C4
    pub i2c4: I2c4,
    ///HPSYS_GPIO
    pub hpsys_gpio: HpsysGpio,
    ///GPTIM2
    pub gptim2: Gptim2,
    ///BTIM2
    pub btim2: Btim2,
    ///HPSYS_AON
    pub hpsys_aon: HpsysAon,
    ///LPTIM1
    pub lptim1: Lptim1,
    ///LPTIM2
    pub lptim2: Lptim2,
    ///PMUC
    pub pmuc: Pmuc,
    ///IWDT
    pub iwdt: Iwdt,
    ///LPSYS_RCC
    pub lpsys_rcc: LpsysRcc,
    ///DMAC2
    pub dmac2: Dmac2,
    ///LPSYS_PINMUX
    pub lpsys_pinmux: LpsysPinmux,
    ///USART4
    pub usart4: Usart4,
    ///USART5
    pub usart5: Usart5,
    ///BTIM3
    pub btim3: Btim3,
    ///BTIM4
    pub btim4: Btim4,
    ///WDT2
    pub wdt2: Wdt2,
    ///PTC2
    pub ptc2: Ptc2,
    ///LPSYS_CFG
    pub lpsys_cfg: LpsysCfg,
    ///LPSYS_AON
    pub lpsys_aon: LpsysAon,
    ///LPTIM3
    pub lptim3: Lptim3,
    ///CRC2
    pub crc2: Crc2,
}
impl Peripherals {
    /// Returns all the peripherals *once*.
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    /// Unchecked version of `Peripherals::take`.
    ///
    /// # Safety
    ///
    /// Each of the returned peripherals must be used at most once.
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            hpsys_rcc: HpsysRcc::steal(),
            extdma: Extdma::steal(),
            hpsys_pinmux: HpsysPinmux::steal(),
            atim1: Atim1::steal(),
            audprc: Audprc::steal(),
            ezip1: Ezip1::steal(),
            epic: Epic::steal(),
            lcdc1: Lcdc1::steal(),
            i2s1: I2s1::steal(),
            hpsys_cfg: HpsysCfg::steal(),
            efusec: Efusec::steal(),
            aes: Aes::steal(),
            trng: Trng::steal(),
            mpi1: Mpi1::steal(),
            mpi2: Mpi2::steal(),
            sdmmc1: Sdmmc1::steal(),
            crc1: Crc1::steal(),
            ptc1: Ptc1::steal(),
            dmac1: Dmac1::steal(),
            usart1: Usart1::steal(),
            usart2: Usart2::steal(),
            usart3: Usart3::steal(),
            gpadc: Gpadc::steal(),
            audcodec: Audcodec::steal(),
            tsen: Tsen::steal(),
            gptim1: Gptim1::steal(),
            btim1: Btim1::steal(),
            wdt1: Wdt1::steal(),
            spi1: Spi1::steal(),
            spi2: Spi2::steal(),
            pdm1: Pdm1::steal(),
            i2c1: I2c1::steal(),
            i2c2: I2c2::steal(),
            i2c3: I2c3::steal(),
            i2c4: I2c4::steal(),
            hpsys_gpio: HpsysGpio::steal(),
            gptim2: Gptim2::steal(),
            btim2: Btim2::steal(),
            hpsys_aon: HpsysAon::steal(),
            lptim1: Lptim1::steal(),
            lptim2: Lptim2::steal(),
            pmuc: Pmuc::steal(),
            iwdt: Iwdt::steal(),
            lpsys_rcc: LpsysRcc::steal(),
            dmac2: Dmac2::steal(),
            lpsys_pinmux: LpsysPinmux::steal(),
            usart4: Usart4::steal(),
            usart5: Usart5::steal(),
            btim3: Btim3::steal(),
            btim4: Btim4::steal(),
            wdt2: Wdt2::steal(),
            ptc2: Ptc2::steal(),
            lpsys_cfg: LpsysCfg::steal(),
            lpsys_aon: LpsysAon::steal(),
            lptim3: Lptim3::steal(),
            crc2: Crc2::steal(),
        }
    }
}
